{"name":"Frontend Components-based Architecture","tagline":"javascript, frontend, architecture","body":"# Intro\r\nThis article is accumulation of my experience building frontend apps architectures. Concepts i am writing about are fine for small and big apps, mobile and web.\r\nI assume that everyone knows BackboneJS basics or at least understands it as pseudocode.\r\n\r\n## Problem\r\nWhen application starts growing it takes more and more time to add new features, catch bugs and make refactoring.\r\n\r\n## Why this happens?\r\n\r\n### Cross dependencies\r\nIt's common practice when you need something that does not exist in current file but exist somewhere else in your project, you are just importing staff you need and use it.\r\n\r\nFor example:\r\n\r\n```js\r\n//header-view.js\r\n\r\nvar StatsView = require('views/stats'),\r\n    StatsModel = require('models/stats');\r\n\r\nvar HeaderView = Backbone.View.extend({\r\n  render: function() {\r\n    var statsModel = new StatsModel(),\r\n        statsView = new StatsView({model: statsModel});\r\n    statsModel.fetch({\r\n      success: function() {\r\n        this.$('.user').html(statsView.render().$el);\r\n      }\r\n    });\r\n  }\r\n});\r\n```\r\n\r\nThis is good and bad.\r\n\r\nGood - it looks pretty easy - if we need show Stats view in some place we can just include it and use.\r\nBad - Header view should know about internal Stats view implementation. It should know that it requires Stats model and should fetch data before render.\r\n\r\nAnd what happens if StatsView will be changed? If it will use for example Collection instead of Model? \r\n\r\nThis case we should make lookup if whole project to understand who is using our StatsView and modify each entry.\r\n\r\nThis moves us to second problem\r\n\r\n### Big scope\r\nDevelopers should always keep in mind whole project because they should know what part of the project is using current file (view, model etc) they are working on.\r\n\r\nThis is fine for small projects but a problem for another. Sometimes we are working with thousands files on one project. And dependencies can be so complex for example this view extends that view which has another mixin we want to change...\r\n\r\nDevelopers start feel fatigue very fast.\r\nEach modification requires \"compiling whole project in the head\" to understand what can be broken and what can be affected by this change.\r\n\r\nAs result - they want start working on something new and small again.\r\n\r\n### DRY (don't repeat yourself)\r\nI think everyone knows this principle. But do we really follow it if we still should write same code (create model, fetching, create view) again and again?\r\n\r\nThe main goal DRY is allow to create something that can be reusable but not cause Cross dependencies and Big scope issues.\r\n\r\n\r\n# Component-based architecture\r\nThis is not something new.\r\nI have just collected practices which helped me solve problems together and use them in my projects. And it works (at least for me).\r\n\r\n## Overview\r\nThe main goal is create reusable components which provides Public API and hides implementation inside.\r\n\r\nFor example:\r\n\r\n```js\r\n// header-view.js\r\n\r\nvar StatsModule = require('modules/stats'),\r\n    statusModuleIns = new StatsModule();\r\n\r\nvar HeaderView = Backbone.View.extend({\r\n  render: function() {\r\n    statusModuleIns.showDetails({\r\n      container: this.$('.user')\r\n    });\r\n  }\r\n});\r\n```\r\n\r\nThis case we follow DRY as much as possible - no code duplication. As bonus we received reusable Stats component which hides implementation and gives Public API - showDetails method.\r\n\r\nWhat inside?\r\nAnything you want.\r\n\r\nExample 1:\r\n\r\n```js\r\n// modules/stats/main.js\r\n\r\ndefine(function(require) {\r\n  var Model = require('./model'),\r\n      View = require('./view'),\r\n      Controller = function() {}\r\n\r\n  Controller.prototype.showDetails = function(container) {\r\n    this.container = container;\r\n    this.model = this.model || new Model();\r\n\r\n    if (this.model.isNew()) {\r\n      this.model.fetch({success: this._renderDetails});\r\n    } else {\r\n      this._renderDetails();\r\n    }\r\n  }\r\n\r\n  Controller.prototype._renderDetails = function() {\r\n    this.detailsView = new View({\r\n      model: this.model\r\n      container: this.container\r\n    });\r\n  }\r\n\r\n  return Controller;\r\n});\r\n```\r\n\r\nOr even Example 2:\r\n\r\n```js\r\n// modules/stats/main.js\r\n\r\ndefine(function(require) {\r\n  var $ = require('jquery'),\r\n      Controller = function() {}\r\n  \r\n  Controller.prototype.showDetails = function(container) {\r\n    $.get('/stats', function(data) {\r\n      $(container).html('<stats>' + data.stats + '</stats>');\r\n    });\r\n  }\r\n\r\n  return Controller;\r\n});\r\n```\r\n\r\nInternal implementation is hidden so developers are not care what's happens inside. Want show stats details? Okay - use showDetails method of Stats component.\r\n\r\n## Benefits\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}