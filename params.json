{"name":"Frontend Components-based Architecture","tagline":"javascript, frontend, architecture","body":"# Intro\r\nThis article is accumulation of my experience in building frontend app architectures. Concepts I am writing about are fine for small and big apps, mobile and web.\r\n\r\nI assume that everyone knows BackboneJS basics or at least understands it as pseudocode.\r\n\r\n## Problem\r\nWhen application starts growing it takes more and more time to add new features, detect bugs and make refactoring.\r\n\r\n## Why does it happen?\r\n\r\n### Cross dependencies\r\nIt's common practice when you need something that does not exist in current file but exists somewhere else in your project and you just import staff you need and use it.\r\n\r\nFor example:\r\n\r\n```js\r\n//header-view.js\r\n\r\ndefine(function(require) {\r\n  var StatsView = require('views/stats'),\r\n      StatsModel = require('models/stats');\r\n\r\n  var HeaderView = Backbone.View.extend({\r\n    render: function() {\r\n      var statsModel = new StatsModel(),\r\n          statsView = new StatsView({model: statsModel});\r\n      statsModel.fetch({\r\n        success: function() {\r\n          this.$('.user').html(statsView.render().$el);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n});\r\n```\r\n\r\nThis has its pros and cons.\r\n\r\nPros are: it looks pretty easy and if we need to show Stats view in some place we can just include it and use.\r\nCons are: Header view should know about internal Stats view implementation. It should know that it requires Stats model and should fetch data before render.\r\n\r\nAnd what happens if Stats view is changed? If it uses, for example Collection instead of Model? \r\n\r\nThis case we should search through the whole project to understand what uses our Stats view and modify each entry.\r\n\r\nThis moves us to second problem.\r\n\r\n### Big scope\r\nDevelopers should always keep in mind the whole project because they should know what part of the project uses view / model they are currently working with.\r\n\r\nThis is fine for small projects, but a problem for another. Sometimes we work with thousands of files in one project. And dependencies can be very complex: this view extends that view which uses another mixin we want to change etc\r\n\r\nDevelopers start feeling fatigue very fast.\r\nEach modification requires \"compiling whole project in the head\" to understand what can be broken and what can be affected by this change.\r\n\r\nAs a result - they want to start working on something new and small again.\r\n\r\n### DRY (don't repeat yourself)\r\nI think everyone knows this principle. But do we really follow it if we still should write same code (create model, fetching, create view) again and again?\r\n\r\nThe main goal of DRY is to allow to create something that can be reusable but not cause Cross dependencies and Big scope issues.\r\n\r\n\r\n# Component-based architecture\r\nThis is not something new.\r\nI have just collected practices which helped me to solve problems together and use them in my projects. And it works (at least for me).\r\n\r\n## Overview\r\nThe main goal is to create reusable components which provide Public API and hide implementation inside.\r\n\r\nFor example:\r\n\r\n```js\r\n// header-view.js\r\n\r\ndefine(function(require) {\r\n  var StatsModule = require('modules/stats'),\r\n      statusModuleIns = new StatsModule();\r\n\r\n  var HeaderView = Backbone.View.extend({\r\n    render: function() {\r\n      statusModuleIns.showDetails({\r\n        container: this.$('.user')\r\n      });\r\n    }\r\n  });\r\n})\r\n```\r\n\r\nIn this case we follow DRY as much as possible - no code duplication. As a bonus we received reusable Stats component which hides implementation and gives Public API - showDetails method.\r\n\r\nWhat is inside?\r\nAnything you want.\r\n\r\nExample 1:\r\n\r\n```js\r\n// modules/stats/main.js\r\n\r\ndefine(function(require) {\r\n  var Model = require('./model'),\r\n      View = require('./view'),\r\n      Controller = function() {}\r\n\r\n  Controller.prototype.showDetails = function(container) {\r\n    this.container = container;\r\n    this.model = this.model || new Model();\r\n\r\n    if (this.model.isNew()) {\r\n      this.model.fetch({success: this._renderDetails});\r\n    } else {\r\n      this._renderDetails();\r\n    }\r\n  }\r\n\r\n  Controller.prototype._renderDetails = function() {\r\n    this.detailsView = new View({\r\n      model: this.model\r\n      container: this.container\r\n    });\r\n  }\r\n\r\n  return Controller;\r\n});\r\n```\r\n\r\nOr even Example 2:\r\n\r\n```js\r\n// modules/stats/main.js\r\n\r\ndefine(function(require) {\r\n  var $ = require('jquery'),\r\n      Controller = function() {}\r\n  \r\n  Controller.prototype.showDetails = function(container) {\r\n    $.get('/stats', function(data) {\r\n      $(container).html('<stats>' + data.stats + '</stats>');\r\n    });\r\n  }\r\n\r\n  return Controller;\r\n});\r\n```\r\n\r\nInternal implementation is hidden so developers don't care what happens inside. Do you want to show stats details? Okay - use showDetails method of Stats component.\r\n\r\n## Benefits\r\n\r\n### No big scope\r\n\r\nDevelopers are working with a small component scope which reduces complexity of changes even in a big application.\r\n\r\nNo need to keep in mind the whole project, because developer takes care about internal implementation and Public API. So they _feel free to make any changes if Public API stays the same_.\r\n\r\nSo even in a big project refactoring or new techniques can be implemented without any problems in local component scope.\r\n  \r\n\r\n### No cross dependencies\r\n\r\nWe are working with high level abstraction - components, not directly with views / models etc. This reduces application complexity and allows reuse implemented functionality.\r\n\r\nSo we can use only controllers Public API to make operations with component. No direct calls to views / models.\r\n\r\n### Testing\r\n\r\nIt's very easy and important to test components.\r\n\r\nUnittests should cover components Public API - in this case we can make any internal changes in the component. If public api requests / responses are the same it means module works as expected. No need to test models / views but we still can be sure in tests results.\r\n\r\n# Practice\r\n\r\n## Application structure\r\n\r\n### Base\r\n\r\nAt first we have to use one place for modules in our application.\r\n\r\n```\r\napplication/\r\n    app.js\r\n    modules/\r\n        stats/\r\n        user/\r\n```\r\n\r\nEach module can have different structure based on which framework is used in application.\r\nFor example Backbone.js\r\n\r\n```\r\napplications/\r\n    modules/\r\n        stats/\r\n            main.js\r\n            models/\r\n                model.js\r\n                collection.js\r\n            views/\r\n                templates/\r\n                    extended.hbs\r\n                    short.hbs\r\n                extended.js\r\n                short.js\r\n```\r\n\r\nModule contains all needed files - views, templates, models, collections etc. Main.js - is entry point of module which provides Public API.\r\n\r\nFor example, if we are using Require.js as AMD loader we can define packages in Require.js config so we can make operations with modules. In this case `main.js` file will be called automatically.\r\n\r\n```js\r\n// config.js\r\n\r\nrequirejs.config({\r\n  ...\r\n  packages: [\r\n    'modules/stats',\r\n    'modules/user'\r\n  ]\r\n});\r\n```\r\n\r\nAnd use it\r\n\r\n```js\r\n// modules/stats/main.js called\r\nvar StatsModule = require('modules/stats');\r\n```\r\n\r\nThis gives us needed level of abstraction.\r\n\r\n### Shared functionality\r\n\r\nWhen application starts growing we see that some functionality is duplicated.\r\n\r\nFor example, we create modal windows and it's nice idea to use some `base-modal-view.js` to avoid duplication.\r\n\r\nThis problem can be solved by placing base shared elements in shared folder\r\n\r\n```\r\napplication/\r\n    app.js\r\n    modules/\r\n    shared/\r\n        views/\r\n            base-modal.js\r\n```\r\n\r\n```js\r\nvar BaseModalView = require('shared/views/base-modal');\r\n\r\nreturn BaseModalView.extend({\r\n});\r\n```\r\n\r\nBut we should keep in mind that `shared/` folder just for _shared base functionality_, not for modules specific views, models etc\r\n\r\n## Components communication\r\n\r\nNext step to reduce components cross dependencies is to disallow using components inside other components.\r\nIn this case we need some controller which allows to do cross-components communication.\r\n\r\nLet's create a new `screens/` folder.\r\n\r\n```\r\napplication/\r\n    app.js\r\n    modules/\r\n    shared/\r\n    screens/\r\n        home/\r\n            main.js\r\n```\r\n\r\nThe role of screen is to include all modules for current screen and make cross-components communication.\r\n\r\n```js\r\n// screens/home/main.js\r\n\r\ndefine(function(require) {\r\n\r\n  // Include all modules that are used in current screen\r\n  var UserModule = require('modules/user'),\r\n      HeaderModule = require('modules/header'),\r\n      Controller = function() {};\r\n\r\n  // When screen starts execute initialize\r\n  Controller.prototype.initialize = function() {\r\n    // Create new User component instance \r\n    this.user = new UserModule();\r\n\r\n    // Create new Header component instance\r\n    this.header = new HeaderModule();\r\n    // If user will click on \"Add\" button in header view\r\n    // we should inform screen and execute needed User Public API\r\n    this.header.on('user:new', this._addNewUser);\r\n    // Use promises to show user details when they will be loaded\r\n    this.user.getDetails().then(this._showUser);\r\n  }\r\n\r\n  Controller.prototype._addNewUser = function() {\r\n    // Open new user modal window\r\n    this.user.showAddModal();\r\n  }\r\n  \r\n  Controller.prototype._showUser = function(details) {\r\n    // Render user details in header\r\n    this.header.show({user: details});\r\n  }\r\n\r\n  return Controller;\r\n});\r\n```\r\n\r\nSo result project structure is\r\n\r\n```\r\napplication/\r\n    app.js\r\n    shared/ <- shared base functionality\r\n        views/\r\n        models/\r\n        utils/\r\n        ...\r\n    modules/ <- reusable components\r\n        user/\r\n        stats/\r\n        news/\r\n        ...\r\n    screens/ <- application \"pages\"\r\n        home/\r\n        news/\r\n        contacts/\r\n        ...\r\n```\r\n\r\nThat's it for now. Feel free to ask questions as github issues for this project https://github.com/artyomtrityak/component-based-architecture/issues","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}